/* tslint:disable */
/* eslint-disable */
/**
 * PlainAPI
 * Create APIs with plain English
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    API,
    APIFromJSON,
    APIToJSON,
    HTTPValidationError,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    Token,
    TokenFromJSON,
    TokenToJSON,
    UserPublic,
    UserPublicFromJSON,
    UserPublicToJSON,
} from '../models';

export interface CreateApiApiV0ApisCreatePostRequest {
    title: string;
    serializedEndpoints: string;
    userId: number;
}

export interface DeleteApiApiV0ApisDeleteDeleteRequest {
    apiId: number;
}

export interface DeleteUserApiV0UsersDeleteDeleteRequest {
    id: number;
}

export interface LogUiErrorApiV0LogUiErrorPostRequest {
    errorInfo: string;
}

export interface LoginUserApiV0UsersLoginPostRequest {
    username: string;
    password: string;
    grantType?: string;
    scope?: string;
    clientId?: string;
    clientSecret?: string;
}

export interface ReadApiApiV0ApisGetByIdGetRequest {
    apiId: number;
}

export interface ReadApisForUserApiV0ApisGetAllForUserGetRequest {
    userId: number;
}

export interface ReadUserApiV0UsersReadByIdGetRequest {
    id: number;
}

export interface ReadUserByEmailApiV0UsersReadByEmailGetRequest {
    email: string;
}

export interface RestartApiApiV0ApisRestartPostRequest {
    aPI: API;
}

export interface SignupUserApiV0UsersSignupPostRequest {
    email: string;
    password: string;
}

export interface UpdateApiApiV0ApisUpdatePatchRequest {
    apiId: number;
    title?: string;
    serializedEndpoints?: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Create Api
     */
    async createApiApiV0ApisCreatePostRaw(requestParameters: CreateApiApiV0ApisCreatePostRequest): Promise<runtime.ApiResponse<API>> {
        if (requestParameters.title === null || requestParameters.title === undefined) {
            throw new runtime.RequiredError('title','Required parameter requestParameters.title was null or undefined when calling createApiApiV0ApisCreatePost.');
        }

        if (requestParameters.serializedEndpoints === null || requestParameters.serializedEndpoints === undefined) {
            throw new runtime.RequiredError('serializedEndpoints','Required parameter requestParameters.serializedEndpoints was null or undefined when calling createApiApiV0ApisCreatePost.');
        }

        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling createApiApiV0ApisCreatePost.');
        }

        const queryParameters: any = {};

        if (requestParameters.title !== undefined) {
            queryParameters['title'] = requestParameters.title;
        }

        if (requestParameters.serializedEndpoints !== undefined) {
            queryParameters['serialized_endpoints'] = requestParameters.serializedEndpoints;
        }

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/apis/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => APIFromJSON(jsonValue));
    }

    /**
     * Create Api
     */
    async createApiApiV0ApisCreatePost(requestParameters: CreateApiApiV0ApisCreatePostRequest): Promise<API> {
        const response = await this.createApiApiV0ApisCreatePostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete Api
     */
    async deleteApiApiV0ApisDeleteDeleteRaw(requestParameters: DeleteApiApiV0ApisDeleteDeleteRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling deleteApiApiV0ApisDeleteDelete.');
        }

        const queryParameters: any = {};

        if (requestParameters.apiId !== undefined) {
            queryParameters['api_id'] = requestParameters.apiId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/apis/delete/`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete Api
     */
    async deleteApiApiV0ApisDeleteDelete(requestParameters: DeleteApiApiV0ApisDeleteDeleteRequest): Promise<any> {
        const response = await this.deleteApiApiV0ApisDeleteDeleteRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete User
     */
    async deleteUserApiV0UsersDeleteDeleteRaw(requestParameters: DeleteUserApiV0UsersDeleteDeleteRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteUserApiV0UsersDeleteDelete.');
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/users/delete/`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Delete User
     */
    async deleteUserApiV0UsersDeleteDelete(requestParameters: DeleteUserApiV0UsersDeleteDeleteRequest): Promise<any> {
        const response = await this.deleteUserApiV0UsersDeleteDeleteRaw(requestParameters);
        return await response.value();
    }

    /**
     * Log Ui Error
     */
    async logUiErrorApiV0LogUiErrorPostRaw(requestParameters: LogUiErrorApiV0LogUiErrorPostRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.errorInfo === null || requestParameters.errorInfo === undefined) {
            throw new runtime.RequiredError('errorInfo','Required parameter requestParameters.errorInfo was null or undefined when calling logUiErrorApiV0LogUiErrorPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.errorInfo !== undefined) {
            queryParameters['error_info'] = requestParameters.errorInfo;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v0/log_ui_error`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Log Ui Error
     */
    async logUiErrorApiV0LogUiErrorPost(requestParameters: LogUiErrorApiV0LogUiErrorPostRequest): Promise<any> {
        const response = await this.logUiErrorApiV0LogUiErrorPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Login User
     */
    async loginUserApiV0UsersLoginPostRaw(requestParameters: LoginUserApiV0UsersLoginPostRequest): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling loginUserApiV0UsersLoginPost.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling loginUserApiV0UsersLoginPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.grantType !== undefined) {
            formParams.append('grant_type', requestParameters.grantType as any);
        }

        if (requestParameters.username !== undefined) {
            formParams.append('username', requestParameters.username as any);
        }

        if (requestParameters.password !== undefined) {
            formParams.append('password', requestParameters.password as any);
        }

        if (requestParameters.scope !== undefined) {
            formParams.append('scope', requestParameters.scope as any);
        }

        if (requestParameters.clientId !== undefined) {
            formParams.append('client_id', requestParameters.clientId as any);
        }

        if (requestParameters.clientSecret !== undefined) {
            formParams.append('client_secret', requestParameters.clientSecret as any);
        }

        const response = await this.request({
            path: `/api/v0/users/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * Login User
     */
    async loginUserApiV0UsersLoginPost(requestParameters: LoginUserApiV0UsersLoginPostRequest): Promise<Token> {
        const response = await this.loginUserApiV0UsersLoginPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Read Api
     */
    async readApiApiV0ApisGetByIdGetRaw(requestParameters: ReadApiApiV0ApisGetByIdGetRequest): Promise<runtime.ApiResponse<API>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling readApiApiV0ApisGetByIdGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.apiId !== undefined) {
            queryParameters['api_id'] = requestParameters.apiId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/apis/get-by-id/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => APIFromJSON(jsonValue));
    }

    /**
     * Read Api
     */
    async readApiApiV0ApisGetByIdGet(requestParameters: ReadApiApiV0ApisGetByIdGetRequest): Promise<API> {
        const response = await this.readApiApiV0ApisGetByIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Read Apis For User
     */
    async readApisForUserApiV0ApisGetAllForUserGetRaw(requestParameters: ReadApisForUserApiV0ApisGetAllForUserGetRequest): Promise<runtime.ApiResponse<Array<API>>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling readApisForUserApiV0ApisGetAllForUserGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.userId !== undefined) {
            queryParameters['user_id'] = requestParameters.userId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/apis/get-all-for-user`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(APIFromJSON));
    }

    /**
     * Read Apis For User
     */
    async readApisForUserApiV0ApisGetAllForUserGet(requestParameters: ReadApisForUserApiV0ApisGetAllForUserGetRequest): Promise<Array<API>> {
        const response = await this.readApisForUserApiV0ApisGetAllForUserGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Read User
     */
    async readUserApiV0UsersReadByIdGetRaw(requestParameters: ReadUserApiV0UsersReadByIdGetRequest): Promise<runtime.ApiResponse<UserPublic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling readUserApiV0UsersReadByIdGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v0/users/read-by-id/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPublicFromJSON(jsonValue));
    }

    /**
     * Read User
     */
    async readUserApiV0UsersReadByIdGet(requestParameters: ReadUserApiV0UsersReadByIdGetRequest): Promise<UserPublic> {
        const response = await this.readUserApiV0UsersReadByIdGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Read User By Email
     */
    async readUserByEmailApiV0UsersReadByEmailGetRaw(requestParameters: ReadUserByEmailApiV0UsersReadByEmailGetRequest): Promise<runtime.ApiResponse<UserPublic>> {
        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling readUserByEmailApiV0UsersReadByEmailGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/users/read-by-email/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPublicFromJSON(jsonValue));
    }

    /**
     * Read User By Email
     */
    async readUserByEmailApiV0UsersReadByEmailGet(requestParameters: ReadUserByEmailApiV0UsersReadByEmailGetRequest): Promise<UserPublic> {
        const response = await this.readUserByEmailApiV0UsersReadByEmailGetRaw(requestParameters);
        return await response.value();
    }

    /**
     * Read Users
     */
    async readUsersApiV0UsersReadAllGetRaw(): Promise<runtime.ApiResponse<Array<UserPublic>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/users/read-all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserPublicFromJSON));
    }

    /**
     * Read Users
     */
    async readUsersApiV0UsersReadAllGet(): Promise<Array<UserPublic>> {
        const response = await this.readUsersApiV0UsersReadAllGetRaw();
        return await response.value();
    }

    /**
     * Restart Api
     */
    async restartApiApiV0ApisRestartPostRaw(requestParameters: RestartApiApiV0ApisRestartPostRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.aPI === null || requestParameters.aPI === undefined) {
            throw new runtime.RequiredError('aPI','Required parameter requestParameters.aPI was null or undefined when calling restartApiApiV0ApisRestartPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v0/apis/restart`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: APIToJSON(requestParameters.aPI),
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Restart Api
     */
    async restartApiApiV0ApisRestartPost(requestParameters: RestartApiApiV0ApisRestartPostRequest): Promise<any> {
        const response = await this.restartApiApiV0ApisRestartPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Signup User
     */
    async signupUserApiV0UsersSignupPostRaw(requestParameters: SignupUserApiV0UsersSignupPostRequest): Promise<runtime.ApiResponse<UserPublic>> {
        if (requestParameters.email === null || requestParameters.email === undefined) {
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling signupUserApiV0UsersSignupPost.');
        }

        if (requestParameters.password === null || requestParameters.password === undefined) {
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling signupUserApiV0UsersSignupPost.');
        }

        const queryParameters: any = {};

        if (requestParameters.email !== undefined) {
            queryParameters['email'] = requestParameters.email;
        }

        if (requestParameters.password !== undefined) {
            queryParameters['password'] = requestParameters.password;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v0/users/signup`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPublicFromJSON(jsonValue));
    }

    /**
     * Signup User
     */
    async signupUserApiV0UsersSignupPost(requestParameters: SignupUserApiV0UsersSignupPostRequest): Promise<UserPublic> {
        const response = await this.signupUserApiV0UsersSignupPostRaw(requestParameters);
        return await response.value();
    }

    /**
     * Update Api
     */
    async updateApiApiV0ApisUpdatePatchRaw(requestParameters: UpdateApiApiV0ApisUpdatePatchRequest): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.apiId === null || requestParameters.apiId === undefined) {
            throw new runtime.RequiredError('apiId','Required parameter requestParameters.apiId was null or undefined when calling updateApiApiV0ApisUpdatePatch.');
        }

        const queryParameters: any = {};

        if (requestParameters.title !== undefined) {
            queryParameters['title'] = requestParameters.title;
        }

        if (requestParameters.serializedEndpoints !== undefined) {
            queryParameters['serialized_endpoints'] = requestParameters.serializedEndpoints;
        }

        if (requestParameters.apiId !== undefined) {
            queryParameters['api_id'] = requestParameters.apiId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            if (typeof this.configuration.accessToken === 'function') {
                headerParameters["Authorization"] = this.configuration.accessToken("OAuth2PasswordBearer", []);
            } else {
                headerParameters["Authorization"] = this.configuration.accessToken;
            }
        }

        const response = await this.request({
            path: `/api/v0/apis/update/`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Update Api
     */
    async updateApiApiV0ApisUpdatePatch(requestParameters: UpdateApiApiV0ApisUpdatePatchRequest): Promise<any> {
        const response = await this.updateApiApiV0ApisUpdatePatchRaw(requestParameters);
        return await response.value();
    }

}
